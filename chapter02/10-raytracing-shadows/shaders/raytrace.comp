#version 450

// Software Ray Tracer using Compute Shader
// 레이 트레이싱의 핵심 개념 학습용
// - 광선-구 교차 (Ray-Sphere Intersection)
// - 광선-평면 교차 (Ray-Plane Intersection)
// - 그림자 광선 (Shadow Rays)
// - Phong 조명 모델

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(binding = 0, rgba8) uniform writeonly image2D outputImage;

layout(push_constant) uniform PushConstants {
    vec4 cameraPos;       // xyz = position, w = fov
    vec4 lightPos;        // xyz = position, w = intensity
    vec4 spherePos;       // xyz = position, w = radius
    vec4 sphereColor;     // rgb = color, a = shininess
    float time;
    float shadowIntensity;
    int showShadows;
    int reflections;
} pc;

// 광선 구조체
struct Ray {
    vec3 origin;
    vec3 direction;
};

// 교차 정보
struct HitInfo {
    bool hit;
    float t;        // 교차 거리
    vec3 point;     // 교차 지점
    vec3 normal;    // 표면 노말
    vec3 color;     // 표면 색상
    float shininess;
};

// 광선-구 교차 테스트
HitInfo intersectSphere(Ray ray, vec3 center, float radius, vec3 color, float shininess) {
    HitInfo info;
    info.hit = false;

    vec3 oc = ray.origin - center;
    float a = dot(ray.direction, ray.direction);
    float b = 2.0 * dot(oc, ray.direction);
    float c = dot(oc, oc) - radius * radius;

    float discriminant = b * b - 4.0 * a * c;

    if (discriminant > 0.0) {
        float t = (-b - sqrt(discriminant)) / (2.0 * a);
        if (t > 0.001) {
            info.hit = true;
            info.t = t;
            info.point = ray.origin + t * ray.direction;
            info.normal = normalize(info.point - center);
            info.color = color;
            info.shininess = shininess;
        }
    }

    return info;
}

// 광선-평면 교차 테스트 (체커보드 바닥)
HitInfo intersectPlane(Ray ray, vec3 planePoint, vec3 planeNormal) {
    HitInfo info;
    info.hit = false;

    float denom = dot(planeNormal, ray.direction);
    if (abs(denom) > 0.001) {
        float t = dot(planePoint - ray.origin, planeNormal) / denom;
        if (t > 0.001) {
            info.hit = true;
            info.t = t;
            info.point = ray.origin + t * ray.direction;
            info.normal = planeNormal;

            // 체커보드 패턴
            vec2 uv = info.point.xz * 0.5;
            bool checker = mod(floor(uv.x) + floor(uv.y), 2.0) < 1.0;
            info.color = checker ? vec3(0.9) : vec3(0.2);
            info.shininess = 32.0;
        }
    }

    return info;
}

// 장면 전체에 대한 광선 추적
HitInfo traceScene(Ray ray) {
    HitInfo closest;
    closest.hit = false;
    closest.t = 1e10;

    // 메인 구
    vec3 sphereCenter = pc.spherePos.xyz;
    sphereCenter.y += sin(pc.time * 2.0) * 0.5;  // 바운스 애니메이션

    HitInfo sphere = intersectSphere(ray, sphereCenter, pc.spherePos.w,
                                      pc.sphereColor.rgb, pc.sphereColor.a);
    if (sphere.hit && sphere.t < closest.t) {
        closest = sphere;
    }

    // 추가 구들 (장면에 다양성 추가)
    vec3 sphere2Center = vec3(-2.0, 0.8, -1.0);
    HitInfo sphere2 = intersectSphere(ray, sphere2Center, 0.8,
                                       vec3(0.2, 0.8, 0.2), 64.0);
    if (sphere2.hit && sphere2.t < closest.t) {
        closest = sphere2;
    }

    vec3 sphere3Center = vec3(2.0, 0.5, 1.0);
    HitInfo sphere3 = intersectSphere(ray, sphere3Center, 0.5,
                                       vec3(0.8, 0.2, 0.2), 32.0);
    if (sphere3.hit && sphere3.t < closest.t) {
        closest = sphere3;
    }

    // 바닥 평면
    HitInfo plane = intersectPlane(ray, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));
    if (plane.hit && plane.t < closest.t) {
        closest = plane;
    }

    return closest;
}

// 그림자 테스트 (그림자 광선)
float traceShadow(vec3 point, vec3 lightDir, float lightDist) {
    Ray shadowRay;
    shadowRay.origin = point + lightDir * 0.01;  // bias to avoid self-intersection
    shadowRay.direction = lightDir;

    HitInfo shadowHit = traceScene(shadowRay);

    if (shadowHit.hit && shadowHit.t < lightDist) {
        return pc.shadowIntensity;  // 그림자 안에 있음
    }
    return 1.0;  // 빛을 받음
}

// Phong 조명 계산
vec3 shade(HitInfo hit, vec3 viewDir) {
    vec3 lightPos = pc.lightPos.xyz;
    vec3 lightDir = normalize(lightPos - hit.point);
    float lightDist = length(lightPos - hit.point);

    // Ambient
    vec3 ambient = 0.15 * hit.color;

    // 그림자 테스트
    float shadow = 1.0;
    if (pc.showShadows != 0) {
        shadow = traceShadow(hit.point, lightDir, lightDist);
    }

    // Diffuse
    float diff = max(dot(hit.normal, lightDir), 0.0);
    vec3 diffuse = diff * hit.color * pc.lightPos.w;

    // Specular
    vec3 halfDir = normalize(lightDir + viewDir);
    float spec = pow(max(dot(hit.normal, halfDir), 0.0), hit.shininess);
    vec3 specular = spec * vec3(1.0) * pc.lightPos.w;

    return ambient + shadow * (diffuse + specular);
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(outputImage);

    if (pixelCoord.x >= imageSize.x || pixelCoord.y >= imageSize.y) {
        return;
    }

    // 카메라 설정
    vec2 uv = (vec2(pixelCoord) + 0.5) / vec2(imageSize);
    uv = uv * 2.0 - 1.0;
    uv.x *= float(imageSize.x) / float(imageSize.y);  // Aspect ratio correction

    // 카메라 광선 생성
    vec3 cameraPos = pc.cameraPos.xyz;
    float fov = pc.cameraPos.w;
    vec3 forward = normalize(vec3(0.0, 0.0, 0.0) - cameraPos);  // Look at origin
    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));
    vec3 up = cross(right, forward);

    vec3 rayDir = normalize(forward + uv.x * right * tan(fov * 0.5) +
                            uv.y * up * tan(fov * 0.5));

    Ray ray;
    ray.origin = cameraPos;
    ray.direction = rayDir;

    // 광선 추적
    HitInfo hit = traceScene(ray);

    vec3 color;
    if (hit.hit) {
        vec3 viewDir = -rayDir;
        color = shade(hit, viewDir);

        // 단순 반사 (1번만)
        if (pc.reflections != 0 && hit.shininess > 50.0) {
            vec3 reflectDir = reflect(rayDir, hit.normal);
            Ray reflectRay;
            reflectRay.origin = hit.point + hit.normal * 0.01;
            reflectRay.direction = reflectDir;

            HitInfo reflectHit = traceScene(reflectRay);
            if (reflectHit.hit) {
                vec3 reflectColor = shade(reflectHit, -reflectDir);
                color = mix(color, reflectColor, 0.3);
            }
        }
    } else {
        // 배경 (그라데이션 하늘)
        float t = 0.5 * (rayDir.y + 1.0);
        color = mix(vec3(1.0), vec3(0.5, 0.7, 1.0), t);
    }

    // 감마 보정
    color = pow(color, vec3(1.0 / 2.2));
    color = clamp(color, 0.0, 1.0);

    imageStore(outputImage, pixelCoord, vec4(color, 1.0));
}
